---
title: 2019-02-01-algorithms4-2
abbrlink: afac
tags:
---

### 3.2 二叉查找树

主要有查找、删除、插入三个操作。

#### 3.2.1 查找

在二叉查找树中查找一个键的递归算法：如果树是空的，则查找未命中；如果被查找的键和根结点的键相等，查找命中，否则我们就（递归地）在适当的子树中继续查找。如果被查找的键较小就选择左子树，较大则选择右子树。

```java
public Value get(Key key) {
    return get(root, key);
}

private Value get(Node x, Key key) {
    // 在以 x 为根结点的子树中查找并返回 key 所对应的值
    if(x == null)
        return null;
    int cmp = key.compareTo(x.key);
    if(cmp < 0)
        return get(x.left, key);
    else if(cmp > 0)
        return get(x.right, key);
    else
        return x.val;
}
```

#### 3.2.2 插入

```java
public void put(Key key, Value val) {
    // 查找 key，找到则更新它的值，否则为它创建一个新的结点
    root = put(root, key, val);
}

private Node put(Node x, Key key, Value val) {
    // 如果 key 存在于以 x 为根结点的子树中则更新它的值；
    // 否则将以 key 和 val 为键值对的新结点插入到该子树中
    if(x == null)
        return new Node(key, val, 1);
    int cmp = key.compareTo(x.key);
    if(cmp < 0)
        x.left = put(x.left, key, val);
    else if(cmp > 0)
        x.right = put(x.right, key, val);
    else
        x.val = val;
    x.N = size(x.left) + size(x.right) + 1;
    return x;
}
```

#### 3.2.3 查找最大键与最小键

利用二叉平衡树的有序性可以很快的用递归算法找到 min 与 max。

```java
public Key max() {
    return max(root).key;
}

private Node max(Node x) {
    if(x.right == null)
        return x;
    return min(x.right);
}

public Key min() {
    return min(root).key;
}

private Node min(Node x) {
    if(x.left == null)
        return x;
    return min(x.left);
}
```

#### 3.2.4 向上向下取整

```java
public Key floor(Key key) {
    Node x = floor(root, key);
    if(x == null)
        return null;
    return x.key;
}

private Node floor(Node x, Key key) {
    if(x == null)
        return null;
    int cmp = key.compareTo(x.key);
    if(cmp == 0)
        return x;
    if(cmp < 0)
        return floor(x.left, key);
    Node t = floor(x.right, key);
    if(t != null)
        return t;
    else
        return x;
}
```

#### 3.2.5 删除

二叉查找树最难实现的就是 delete() 操作。

现看如何删除最小键 deletemin()：

```java
public void deleteMin() {
    root = deleteMin(root);
}

private Node deleteMin(Node x) {
    if(x.left == null)
        return x.right;
    x.left = deleteMin(x.left);
    x.N = size(x.left) + size(x.right) + 1;
    return x;
}
```

再看删除一般节点的情况，对于删除一个拥有两个子结点的情况，在删除结点 x 后用它的**后继结点**填补它的位置。因为 x 有一个右子结点，因此它的后继结点就是**其右子树中的最小结点**。这样的替换仍然能保证树的有序性，因为 x.key 和它的后继结点的键之间不存在其他的键。

用 4 个简单的步骤能够完成将 x 替换为它的后继结点的任务：

1. 将指向即将被删除的结点的链接保存为 t；
2. 将 x 指向它的后继结点`min(t.right)`；
3. 将 x 的**右链接**（原本指向一棵所有结点都大于 x.key 的二叉查找树）指向`deleteMin(t.right)`，也就是在删除后所有结点仍然大于 x.key 的子二叉查找树；
4. 将 x 的**左链接**（本为空）设为 t.left（其下所有的键都小于被删除的结点和它的后继结点）。

对于某些大规模的实际应用，这种方法可能会有一点性能上的问题。

```java
public void delete(Key key) {
    root = delete(root, key);
}

private Node delete(Node x, Key key) {
    if(x == null)
        return null;
    int cmp = key.compareTo(x.key);
    if(cmp < 0)
        x.left = delete(x.left, key);
    else if(cmp > 0)
        x.right = delete(x.right, key);
    else {
        if(x.right == null)
            return x.left;
        if(x.left == null)
            return x.right;
        Node t = x;
        x = min(t.right);
        x.right = deleteMin(t.right);
        x.left = t.left;
    }
    x.N = size(x.left) + size(x.right) + 1;
    return x;
}
```

#### 3.2.6 范围查找

```java
public Iterable<Key> keys() {
    return keys(min(), max());
}

public Iterable<Key> keys(Key lo, Key hi) {
    Queue<Key> queue = new Queue<Key>();
    keys(root, queue, lo, hi);
    return queue;
}

private void keys(Node x, Queue<Key> queue, Key lo, Key hi) {
    if(x == null)
        return;
    int cmplo = lo.compareTo(x.key);
    int cmphi = hi.compareTo(x.key);
    if(cmplo < 0)
        keys(x.left, queue, lo, hi);
    if(cmplo <= 0 && cmplo >= 0)
        queue.enqueue(x.key);
    if(cmphi > 0)
        keys(x.right, queue, lo, hi);
}
```



### 平衡查找树

前几种算法在最坏情况下的性能还是很糟糕。本节中介绍一种二分查找树并能保证无论如何构造它，它的运行时间都是对数级别的。

理想情况下，我们希望能够保持二分查找树的平衡性，以使树高为 ~lgN，这样就能保证所有查找都能在 ~lgN 次比较内结束。